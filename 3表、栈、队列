/*链表的类型声明*/
＃ifndef  _List_H
struct Node;
typedef struct Node *PtrToNode;
typedef PtrToNode List;
typedef PtrToNode Position;

List MakeEmpty(List L);
int IsEmpty(List L）；
int Islast(Position P,List L);
Position Find(ElementType X,List L);
void Delete(ElementType X,List L);
position FindPrevious(ElementType X,List L);
void Insert(ElementType X, List L, Position P);
void DeleteList(List L);
Position Header(List L);
Position First(List L);
Position Advance(Position P);
ElementType Retirieve(Position P);

#endif  /*_List_H*/

/*Place in the implementation file*/
struct Node
{
  ElementType Element;
  Position Next;
 };
 
 
 /*测试一个链表是否是空表*/
 int Isempty(List L)
 {
  return L->Next == NULL;
  }
  
  
  /*测试当前位置是否是链表的末尾的函数*/
  int Islast(Position P,List L)
  {
    return P->Next ==NULL;
   }
   
 /*Return Position of X in L; NULL if not found*/
 Position Find(ElementType X,List L)
 {
    Position P;
    p = L->Next;
    while(P!=NULL && P->Element !=X)
        p = p->Next;
        
    return P;
    }
    
  /*链表删除*/
  void Delete(ElementType X,List L)
  {
    Position P, TmpCell;
    P= Findprvvious(X,L);
    
    if(!Islast(P,L)
    {
        TmpCell = P->Next;
        P->Next =TmpCell->Next;
        free(TmpCell);
     }
   }
   
   
   /*插入元素*/
   Position FindPrevious(ElementType X,List L)
   {
      Position P;
      while(P->Next!=NULL && P->Next->Element!=x)
          P = P->Next;
      return P;
      }
      
      
    void Insert(ElementType X, List L, Position P)
    {
        Position TmpCell;
        
        TmpCell = mallcon (sizeof(struct Node));
        if(TmpCell == NULL)
            Fatalerror("out of space!!");
        TmpCell->Element = x;
        TmpCell->Next = P->Next;
        P->Next = TmpCell;
      }
      
   /*删除表*/
   
   void DeleteList(List L)
   {
      Position P,Tmp;
      P=L->Next
      L->Next=NULL;
      while(P!=NULL)
      {
          Tmp = P->Next;
          free(P);
          P=Tmp;
       }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    /*链表游标实现的声明*/
    ＃ifndef  _Cursor_H
    
    typedef int PtrToNode;
    typedef PtrToNode List;
    typedef PtrToNode Position;
    
    void InitializeCursorSpace(void);

    List MakeEmpty(List L);
    int IsEmpty(const List L）；
    int Islast(const Position P,const List L);
    Position Find(ElementType X,const List L);
    void Delete(ElementType X,List L);
    position FindPrevious(ElementType X,const List L);
    void Insert(ElementType X, List L, Position P);
    void DeleteList(List L);
    Position Header(const List L);
    Position First(const List L);
    Position Advance(const Position P);
    ElementType Retirieve(const Position P);

    #endif  /*_Cursor_H*/

    /*Place in the implementation file*/
    struct Node
    {
      ElementType Element;
      Position Next;
     };
    
    struct Node CursorSpace[ SpaceSize ];
    
    
    /*例程：CursorAlloc和CursorFree*/
    static Position
    CursorAlloc(void)
    {
        Position P;
        
        P=CursorSpace[0].next;
        Cursorspace[0].Next=CursorSpace[P].Next;
        
        return P;
     }
     
     static void 
     CursorFree(Position P)
     {
        CursorSpace[P].Next = CursorSpace[0].Next;
        CursorSpace[0].Next = P;
     }
     
     /*测试一个链表是否为空的函数---游标实现*/
     int IsEmpty(List L)
     {
          return CursorSpace[ L ].next == 0;
     }
     
     /*测试P是否是链表的末尾的函数*/
     int IsLast(Position P,List L)
     {
        return CursorSpace[P].Next == 0
        }
       
     /*例程Find----------游标实现*/
     Position
     Find(ElementType X,List L)
     {
        Position P;
        
        P=CursorSpace[ L ].Next;
        while(p && CursorSpace[P].Element!=X)
            p=CursorSpace[P].Next;
        
        return P;
      }
      
      /*对链表进行删除操作的例程-----------游标实现*/
      void
      Delete(ElementType X,List L)
      {
          Position P,TmpCell;
          
          P = FindPrevious(X,L);
          
          if(!Islast(P,L))
          {
              TmpCell = CursorSpace[P].Next;
              CursorSpace[P].Next = CursorSpace[TmpCell].Next;
              cursorFree(TmpCell);
           }
        }
        
 /*对链表进行插入操作的例程-------游标实现*/
        
void 
Insert(ElementType X,List L,Position P)
{
   Position TmpCell;
   
   TmpCell = CursorAlloc();
   if(TmpCell==0)
      FatalError("超出空间");
      
   CursorSpace[TmpCell].Element=X;
   CursorSpace[TmpCell].Next=CursorSpace[P].next;
   CursorSpace[P].Next=TmpCell;
 }
